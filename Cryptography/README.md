# Cryptography


- [Generate Random Cryptographically Secure Token - *( for token and API keys)*](#random_token)
- [UUIDs](#uuids)
- [bycrypt](#bycrypt)   <--------- to be done TODO
- [Symmetric vs Asymmetric Encryption](./SymmetricAsymmetricEncryption.md)
    - [Symmetric Java examples](./SymmetricAsymmetricEncryption.md/#symmetric_java)
    - [Asymmetric Java examples](./SymmetricAsymmetricEncryption.md/#asymmetric_java)
    - [ssh-keygen tool to generate public/private keys](./SymmetricAsymmetricEncryption.md/#asymmetric_ssh_keygen)
    - [Java keytool to generate public/private keys](./SymmetricAsymmetricEncryption.md/#asymmetric_java_keytool)
- [Digital Signature](./DigitalSignature.md)
- [Digital Certificate](./DigitalCertificate.md)



## <a name='map'> Generate Random Cryptographically Secure Token </a>


Use **SecureRandom**: A class provides a cryptographically strong random number generator (RNG)

```java

private String generateSafeToken() {
    SecureRandom random = new SecureRandom();
    byte bytes[] = new byte[20];
    random.nextBytes(bytes);
    Encoder encoder = Base64.getUrlEncoder().withoutPadding();
    String token = encoder.encodeToString(bytes);
    return token;
}

``` 

## <a name='uuids'> UUIDs </a>

UUIDs of any kind **do not promise to be cryptographically secure** as it is not guaranteed in the [RFC](https://www.rfc-editor.org/rfc/rfc4122).   
Certain implementations may use a cryptographically secure random number generator, but we wouldn't rely on it.



The representation of the UUID uses hex digits
```
237e9877-e79b-12d4-a765-321741963000  
```
- Java UUID is made up of hex digit along with four hyphens (-). It is 36 characters long unique number, including four hyphens. A UUID may be nil, in which all bits are set to zero.
- Java UUID class are for manipulating the Leach-Salz variant,

- The layout of a variant 2 (Leach-Salz) UUID is as follows: The most significant long consists of the following unsigned fields:

```
     0xFFFFFFFF00000000 time_low
     0x00000000FFFF0000 time_mid
     0x000000000000F000 version
     0x0000000000000FFF time_hi
``` 
#### The UUID Versions

1. **Version 1**   
    - UUID version 1 is based on the current timestamp, measured in units of 100 nanoseconds from October 15, 1582, concatenated with the MAC address of the device where the UUID is created.
2. **Version 2**
    - It is based on a timestamp and the MAC address as well. However, [RFC 4122](https://tools.ietf.org/html/rfc4122) does not specify the exact generation details, so we won't look at an implementation in this article.
3. **Version 3 and 5**
    - The UUIDs are generated using the hash of namespace and name. The namespace identifiers are UUIDs like Domain Name System (DNS), Object Identifiers (OIDs), URLs, etc.
    - The only difference between UUIDv3 and UUIDv5 is the Hashing Algorithm — v3 uses MD5 (128 bits), while v5 uses SHA-1 (160 bits).
      
    This code generates a v3 UUID (name-based)
    ```java
       byte[] byteArr = {11, 23, 33}; 
       UUID uuid = UUID.nameUUIDFromBytes(byteArr);
       System.out.println("UUID version is: "+uuid.version());     //invoking version method  
    ```       
4. **Version 4**
    - The UUIDv4 implementation uses random numbers as the source. The Java implementation is **SecureRandom**, which uses an unpredictable value as the seed to generate random numbers to reduce the chance of collisions.
    ```java
       UUID uuid = UUID.randomUUID();
       System.out.println("UUID version is: "+uuid.version());     //invoking version method  
    ```   
   
    Let's generate a unique key using “SHA-256” and a random UUID:
    ```java
       MessageDigest salt = MessageDigest.getInstance("SHA-256");
       salt.update(UUID.randomUUID().toString().getBytes("UTF-8"));
       String digest = bytesToHex(salt.digest());
    ```  


## <a name='bycrypt'> bycrypt </a>

##### Introduction
1. **Plain Text** is dangerous as the attacker can steal the database with passwords or get access to the passwords by other methods like SQL injection.
2. **Hashing** Hashing solves the problem of immediate access to the system with exposed passwords.
    **BUT**
    - Using rainbow tables, attackers still can have success, however. A rainbow table is a table with precomputed hashes for many passwords. There are many rainbow tables available on the internet and some of them contain millions of passwords.
3. **Salting the Password** A salt is a sequence of randomly generated bytes that is hashed along with the password. The salt is stored in the storage and doesn’t need to be protected.
    **BUT**
    - A salt can make the attack difficult for the attacker, but hardware is getting more efficient, the attacker can calculate billions of hashes per second.
    **Thus Thus, hashing and salting are necessary - but not enough.** 
4. **Work Factor** The work factor is a configuration of the encoding algorithms that we can increase with growing hardware power.
    - For instance, **bcrypt** has the parameter strength. The algorithm will make 2 to the power of strength iterations to calculate the hash value. The bigger the number, the slower the encoding.
        
##### BCryptPasswordEncoder with Spring Security

to encode the password
```java
    int strength = 10; // work factor of bcrypt
    BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(strength, new SecureRandom());
    String encodedPassword = bCryptPasswordEncoder.encode(plainPassword);
```                                                                                                     

- BCryptPasswordEncoder has the parameter strength. The default value in Spring Security is 10. It’s recommended to use a SecureRandom as salt generator, because it provides a cryptographically strong random number.
- We just need to save th **encodedPassword** into the datbase (no need to save the salt in case of bcrypt)
- The **output of encodedPassword** looks like this:

> $2a$10$ZLhnHxdpHETcxmtEStgpI./Ri1mksgJ9iDP36FmfMdYyVg9g0b2dq


There are three fields separated by $:  
   - The **“2a”** represents the BCrypt algorithm version
   - The **“10”** represents the strength of the algorithm **(work factor, here 2^10 rounds)**
   - The **“ZLhnHxdpHETcxmtEStgpI.”** part is actually the randomly generated salt. Basically, the first 22 characters are salt. The remaining part of the last field is the actual hashed version of the plain text
   
to match the password
```java
    bCryptPasswordEncoder.matches("plain-password", encodedPassword);
```   

For more information, revise **Spring Security** examples.

 